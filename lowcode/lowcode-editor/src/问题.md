## 学习与自测问题（lowcode-editor / src）

### 架构与工程

- **Allotment 分栏**: `preferredSize/minSize/maxSize/snap` 的差异与最佳实践？三栏嵌套分栏时重绘与性能注意点？
- **路径别名**: 代码中使用 `@components/*`，对应的 Vite `resolve.alias` 与 TS `paths` 在哪里配置？构建与 IDE 跳转是否一致？
- **样式体系**: Tailwind 在该项目的 PostCSS/配置文件如何接入？生产环境的样式裁剪（Purge）是否开启？

### 状态管理（zustand / 组件树）

- **不可变更新**: `addComponent` 在对子节点 push 时，是否存在直接修改引用的问题？如何确保 React 能正确触发渲染？
- **删除能力**: `deleteComponent` 目前只处理有 `parentId` 的子节点，如何安全地删除根节点或孤立根级节点？
- **更新能力**: 如何实现 `updateComponent` 与 `updateComponentProps`（包含深层节点的定位与合并）？
- **查找算法**: `getComponentById` 为 DFS，是否需要同时提供 `getParentById` 或返回路径（path）以便批量更新？
- **ID 策略**: 组件 `id` 如何生成以避免冲突？是否需要集中 ID 服务或 `nanoid`？
- **选中态**: 编辑器通常需要“当前选中组件”的状态，是否应在 store 中增设 `selectedId` 与相关 actions？

### 编辑器交互

- **物料 -> 画布**: `Material` 到 `EditorArea` 的拖拽（如 dnd-kit）如何设计落点与 parentId 计算？
- **属性联动**: `Setting` 如何根据 `selectedId` 自动渲染表单？是否需要按物料 schema 动态生成表单控件？
- **历史记录**: 是否需要 `undo/redo`（可基于 `immer` 的 patch 或自定义快照策略）？
- **持久化**: 组件树如何持久化（本地存储 / 远端接口）？如何做版本化与导入导出？

### 渲染与性能

- **大树性能**: 当组件树很大时，如何优化 `getComponentById` 与频繁更新（例如建立 id -> node 的索引缓存）？
- **渲染隔离**: 画布节点渲染是否需要虚拟化或按需展开？
- **序列化**: `props: Record<string, unknown>` 是否需要限定可序列化，以便保存与回放？

### 代码组织与约定

- **物料定义**: 不同物料（如 `Video`、`Container`）的 `props`、`desc`、默认值与校验应如何抽象（schema/类型）？
- **事件模型**: 物料的事件（点击、播放等）如何在低代码中声明、绑定与执行？
- **安全与校验**: 用户输入的 `props`/表达式如何做安全校验与沙箱隔离？

### 实践任务（可作为进阶 TODO）

- 实现 `updateComponent` 与 `updateComponentProps`，并新增根节点删除能力。
- 引入 `nanoid` 统一 id 生成；为 `EditorArea` 添加“选中态”与属性面板联动。
- 在 `Material` 与 `EditorArea` 之间接入拖拽，完成落点 parentId 计算与插入。
- 设计物料 `schema` 与 `Setting` 的动态表单渲染；支持持久化与导出。
